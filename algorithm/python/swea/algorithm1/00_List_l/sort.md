## 정렬

### 버블정렬
> 인접한 두개의 원소를 비교하며 자리를 계속 교환하는 방식

#### 정렬과정
1. 첫번째 원소부터 인접한 원소끼리 계속 자리를 교환
2. 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬
3. 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양과 같다고 하여 버블정렬이라고 함

#### 시간복잡도 
- O(n**2)

```python
def asc(arr,N):
    for i in range(N-1,0,-1):
        for j in range(i):
            if arr[j] > arr[j+1]:
                arr[j],arr[j+1] = arr[j+1],arr[j]
    return arr
def dec(arr,N):
    for i in range(N-1,0,-1):
        for j in range(i):
            if arr[j] > arr[j+1]:
                arr[j],arr[j+1] = arr[j+1],arr[j]
    return arr
```

### 카운팅 정렬
1. 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여 선형 시간에 정렬하는 효율적인 알고리즘
   1. 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
   2. 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함

2. 1단계
    - Data에서 각 항목들의 발생 횟수를 세고, 정수 항목들로 직접 인덱스되는 카운트 배열 counts에 저장
    - 숫자의 최댓값만큼 counts 배열을 만들어야함
'''
□ [0,4,1,3,2,4,1]을 카운팅 정렬을 하는 과정
Data에서 입력된 데이터 가짓수가 counts 갯수는 k+1개이므로

- 처음에 counts =[0,0,0,0,0]임 
[0,4,1,3,2,4,1]을 하나씩 순회하여 counts 각 자리에 하나씩 +=1
- counts = [1,3,1,1,2]임 
정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영
- 앞 원소의 값을 누적해서 계속 합한다.
[1,3,1,1,2] --> [1,4,5,6,8]
- 활용하는 방법
1~3까지의 구간에서만 합계를 구한다하면
3까지 누적합 - 0까지의 구간합
'''
3. 2단계
    - 숫자 1이 나온다면, 임시 리스트 temp에 4번째 넣고, counts 행렬에 1을 깎음 
    - 숫자 4가 나온다면, 임시 리스트 temp에 8번째 넣고, counts 행렬에 1을 깎음.. 반복
    - temp에는 그렇게 되면 순서대로 정렬됨 O(n+k)가 시간복잡도(n=k)
```python
def Counting_sort(Data,temp,k):
    data = input().split()
    temp = [] # 정렬된 배열

    counts = [0]*(k+1) # 카운트 배열

    for i in range(0,len(data)):
        counts[data[i]]+=1

    for i in range(1,k+1):
        counts[i] +=counts[i-1]
    
    for i in range(len(temp)-1,-1,-1):
        counts[data[i]]-=1
        temp[counts[data[i]]]=data[i]
```

### 완전 검색
1. 특징
   - 모든 경우의 수를 테스트한 후, 최종 해법을 도출한다.
   - 일반적으로 경우의 수가 상대적으로 작을 때 유용하다.
   - 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작다.

2. 고려할 수 있는 모든 경우의 수 생성(baby-gin)
   1. 6개의 숫자로 만들 수 있는 모든 숫자 나열(중복 포함)
   2. 해답 테스트하기  

3. 순열 : 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
```python
for i1 in range(1,4):
    for i2 in range(1,4):
        if i2 !=i1:
            for i3 in range(1,4):
                if i3 !=i1 and i3 != i2:
                    print(i1,i2,i3)
```

### 탐욕 알고리즘
- 최적해를 구하는 데 사용되는 근시안적인 방법
- 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다.
- 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다 해서 그것이 최적이라는 보장은 없음

'''
어떻게 하면 손님에게 거스름돈으로 주는 지폐와 동전의 개수를 최소한으로 줄일 수 있을까?

1) 해선택 : 여기에서는 멀리 내다볼 것 없이 가장 좋은 해를 선택한다. 단위가 큰 동전으로만 거스름돈을 만들면 동전의 개수가 줄어드므로 현재 고를 수 있는 가장 단위가 큰 동전을 하나 골라 거스름돈에 추가한다.
(ex) 
- 10000원을 1000원 500원 100원 단위로 제출한다하면
- 1000원을 최대로 지출, 그 다음 500원을 최대로 제출, 그 다음 100원 최대로 제출한다. 
'''