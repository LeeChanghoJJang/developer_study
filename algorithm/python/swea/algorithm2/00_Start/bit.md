## 비트연산

> 컴퓨터의 CPU는 0과 1로 다루어 동작됨.
> `비트연산`을 활용한 방법 알아보기

#### AND와 OR
> 1. a AND b : a,b 둘다 1일 때만 결과가 1이다. 그 외에는 0
> 2. a OR b : a,b 둘중 하나만 1이면 결과가 1이다. 그 외에는 0
> 3. a XOR b : a,b 같으면 결과가 1이다. 그 외에는 0 

#### 2진수, 16진수, 10진수 변환하여 출력하기
> 1. 2진수는 숫자 0와 소문자 b -> 0b를 접두사로 붙여 표현한다.
> 2. 16진수는 숫자 0와 소문자 x -> 0x를 접두사로 붙여 표현한다.

#### 암호화 프로그램 제작하기
> 1. XOR을 두번 이용하면 본래의 수로 돌아온다는 것을 이용
> 2. 인코딩과 디코딩 가능
```python
print(1000^ 1004)
print(1000^1004^1004)
print(4^1004) 
```
#### Left Right 연산자
> 1. `<<` : Left Shift : 특정 수 만큼 비트를 왼쪽으로 밀어낸다.
> 2. `>>` : Right Shift : 특정 수 만큼 비트를 오른쪽으로 밀어낸다.(우측 비트 제거)

#### Left Shift를 이용한 프로그래밍
```python
for i in range(5):
    print(bin(1<<i))
```

#### 2의 보수 
> 1의보수 + 1
> 1의 보수는 전부다 뒤집으면 됨
> 그래서 맨앞 부호가 0이면 양수 1이면 음수
> 예시
> - 수 5를 2진수로 나타내면 `000 0101` (7bit)
> - `-5`는 음수기에 MSB는 1이다.
> - 나머지 7bit에 대해 수를 뒤집고 1을 더하면 된다.(`2의 보수`)
> - 수 5를 뒤집으면 `111 1010`이며, 1을 더하면 `111 1011`
> - 따라서 `1111 1011`이 된다. 

#### NOT 연산자
> ~: 모든 비트를 반전시킨다. 
> 예시 : ~4
> NOT 연산자로 인해 뒤집으면 1011이 된다.
> MSB는 1이 되었고 (음수), 나머지 bit는 011이다.
> 나머지 bit에 대해 2의 보수를 취하면 100 + 1 =100이므로 5가 된다. 
> 따라서 -5가 된다. 

#### 도전과제 : 전부 1로 되어있는가 N갯수만큼
```python
N = 5
M=31

def on(N,M):
    while N:
        if not M&(1<<(N-1)):
             return 'OFF'
        N-=1
    else:
        return 'ON'
print(on(N,M))

def Test():
    tar = M
    for i in range(N):
        if tar & 0x1 ==0:
            return False
        tar = tar >> 1
    return True
print(Test())
```

#### 실수
> {t2:.2f} : t2값을 소수점 둘째자리까지 반올림
> 최대 표현할 수 있는 값은 약 1.8 * 10^308
> 최소 표현할 수 있는 값은 약 5.0 * 10^-324

> 실수를 내부적으로 근사적인 관리 : 생각안해도 될정도로 매우 작은 오차
```python
print(0.1+0.1+0.1==0.3) #False로 나옴
```

#### 도전과제 : 실수 값 출력해보기
```python
print(f'{0.1:.20f}')
```
> 실수는 정확한 값이 아니고, 근삿값이다.

### 근사값으로 저장되는 원리
> 1. 2^-1 + 2^-2 == 0.11(2)
> 2. 2^-2 + 2^-3 + 2^-5 == 0.01101(2)
